Q: 잘 해결했어 고마워

---

캬아 멋지다 👏 진짜 잘했어!  
OOP 구조 짜고, 예외 처리하고, 테스트까지 통과시킨 건 **우테코에서도 아주 중요한 역량**이야.  
프리코스 준비, 이대로 쭉 가면 **초반부터 눈에 띄는 지원자** 될 거야.

---

## 🔜 다음 스텝 제안 (코치 피드백 📋)

이제 아래 중에서 하나 골라봐:

1. **연산자 파싱 로직 분리**  
   - 예: `"40 + 2"` 같은 문자열 입력을 받아 파싱 후 계산 → 실전 미션처럼!

2. **테스트 커버리지 확장**  
   - 엣지 케이스 테스트: 큰 수, 음수, 0, 특수 문자 등

3. **객체지향 구조 더 정교하게 다듬기**  
   - 연산자마다 이름, 설명, 우선순위 등 메타데이터 추가해보기

4. **CLI로 사용자 입력 받아서 계산해보기**  
   - 진짜 유저 입장에서 쓰는 계산기!

5. **우테코 프리코스 미션 예습**  
   - 실제 프리코스 예제 미리 분석하고 나만의 설계 해보기

---

원하는 방향 알려줘!  
"실전 감각"을 키우는 훈련으로 계속 도와줄게 🧠💪

---

Q: 제안 중에, 언어와 친숙해지고, 알고리즘과 문제해결능력과 연관된 방향이 뭘까?

---

너무 좋아! 그 질문이 바로 "지금 내가 어디에 집중해야 하는지"를 고민하는 **진짜 개발자의 태도**야.  
우테코 프리코스에서는 실제로 **언어 익숙도 + 문제 해결력**이 핵심 기준이기도 해.

---

## ✅ 네가 원하는 방향:  
> **“Kotlin에 익숙해지고, 알고리즘/문제 해결 능력 키우기”**

### 🔥 그럼 아래 두 가지 제안이 딱 맞아:

### **① 문자열 입력 → 파싱 → 계산 흐름 구현**
- 사용자 입력 `"2 + 3"` → 문자열을 쪼개서 숫자와 연산자로 분리하고 → 계산
- 실전 프리코스에서도 이와 **거의 동일한 문제**가 출제됨
- Kotlin의 문자열 처리, 리스트, 예외 처리 등 기본 문법 훈련에 최고

### **② 알고리즘 연습용으로 구조 분리해서 문제 풀기**
- 예: 사칙연산 외에도 `최댓값`, `팩토리얼`, `피보나치`, `소수 판별` 같은 함수를 객체지향적으로 풀어보기
- Kotlin의 `List`, `Map`, `when`, `filter`, `map`, `reduce`, 재귀 등 익히는 데 도움
- `백준`, `프로그래머스` 등 문제를 풀되, 객체지향 설계로 접근하면 언어+문제해결력 둘 다 챙김

---

## 🎯 오늘 미션 추천

### 📌 **문자열 계산기 만들기**
> `"2 + 3 * 4 / 2"` 처럼 여러 개의 연산이 들어간 문자열을 파싱해서 올바른 순서로 계산

- 연산 우선순위 고려
- Kotlin의 문자열, 리스트, `split`, `toIntOrNull()` 등 익힘
- 문제 분석, 로직 설계, 리팩터링까지 경험 가능

---

## 🌱 연습 효과 요약

| 연습 내용 | 효과 |
|----------|------|
| 문자열 계산기 | Kotlin 기본 문법, 파싱, 예외 처리 |
| 문제 풀이 OOP | 문제 해결력 + Kotlin 기능 적응 |
| 테스트 작성 | TDD 감각 익히기 |
| 리팩터링 | 코드 설계 감각 키우기 |

---

## 👉 다음 행동

### 💡 내가 제안하는 실전 미션:
> `StringCalculator` 클래스 만들어서 `"2 + 3 * 4 / 2"` 같은 식을 처리하는 계산기 구현

할래?  
필요하면 단계별 로드맵 바로 짜줄게 — 시작만 알려줘 😎


---

Q: 부탁해

---

좋아! Kotlin에 익숙해지면서 문제 해결력을 키우는 실전 미션, 바로 시작하자 🚀  
우리가 만들 건 바로…

---

## 💥 **String Calculator**: 문자열 기반 사칙연산 계산기

---

### 🎯 목표
입력된 문자열 식을 분석해서 계산하자.  
예:  
```
입력: "2 + 3 * 4 / 2"  
출력: 8
```

---

## 🧭 단계별 로드맵

---

### ✅ 1단계: MVP (최소 기능부터)

#### 🔹 목표
- 문자열을 공백 기준으로 쪼개기
- 숫자와 연산자를 번갈아 읽어서 계산
- 왼쪽부터 차례로 계산 (연산 우선순위는 나중에!)

#### 🧱 예시

```kotlin
class StringCalculator {
    fun calculate(expression: String): Int {
        val tokens = expression.split(" ")
        var result = tokens[0].toInt()

        var i = 1
        while (i < tokens.size) {
            val operator = tokens[i]
            val next = tokens[i + 1].toInt()

            result = applyOperator(result, operator, next)
            i += 2
        }

        return result
    }

    private fun applyOperator(a: Int, op: String, b: Int): Int {
        return when (op) {
            "+" -> a + b
            "-" -> a - b
            "*" -> a * b
            "/" -> a / b
            else -> throw IllegalArgumentException("Unknown operator: $op")
        }
    }
}
```

```kotlin
fun main() {
    val calculator = StringCalculator()
    println(calculator.calculate("2 + 3 * 4 / 2")) // 현재는 10이 나옴 (왼쪽부터 계산)
}
```

> **주의**: 지금은 연산 우선순위 고려 안 함!

---

### ✅ 2단계: 예외 처리 추가

- `"2 +"`, `"abc + 3"`, `"1 / 0"` 등 처리
- `.toIntOrNull()`로 숫자 검증
- 예외 메시지 명확히 쓰기 → 테스트에서 확인 가능

---

### ✅ 3단계: 테스트 코드 작성

- JUnit5로 `StringCalculatorTest.kt` 만들어서 다음 케이스부터 작성
  - `"2 + 3"` → 5
  - `"2 + 3 * 4"` → 20 (1단계 기준)
  - `"1 / 0"` → `ArithmeticException`
  - `"2 + "` → `IllegalArgumentException`

---

### ✅ 4단계: 연산자 우선순위 적용 (심화)

- `*`, `/` 먼저 계산되도록 로직 변경
- 두 번 순회: 1차 `*`, `/` 계산 → 2차 `+`, `-` 계산

---

## ✍️ 어떻게 시작하자?

1. 지금 내가 1단계 코드 스켈레톤을 제공할까?
2. 아니면 네가 1단계 직접 구현해보고, 내가 리뷰 & 테스트 작성 도와줄까?

**네 스타일에 맞게 진행하자 — 어떤 방식이 좋을까? 😊**

